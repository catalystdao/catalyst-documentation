---
title: "Overview"
slug: "architecture/overview"
description: "Overview of the Catalyst full-stack intents system"
sidebar:
  order: 0
---

Catalyst is modularises three components of the cross-chain intent flow:

1. **Input settlement scheme** - Handles the source chain funds
2. **Output settlement scheme** - Handles the destination chain funds
3. **Validation layer** - Connects the input and output settlement

Historically, these components have been intertwined, presenting issues with scaling. Catalyst's componentized approach allows for greater flexibility and extensibility, allowing for different input and output settlement schemes, and validation layers. This allows Catalyst to support varying degrees of asset technologies: fill first, user as solver, and ordinary swaps.

## Core Components

### Input Settlement

The input settlement scheme is responsible for managing user deposits and releasing funds to solvers once intents are fulfilled. Catalyst currently implements two input settlement schemes:

- [**TheCompact**](https://github.com/Uniswap/the-compact) through `CompactSettlerWithDeposit.sol`
- [**Rhinestone**](https://www.rhinestone.wtf) through `CompactSettler.sol`

Both are resource locks supporting fill-first flows, though Catalyst also supports ordinary flows.

Catalyst imposes no restriction on the implementation of input settlements. Input Settlements can access proven output through the validation layer by either `isProven` or `efficientRequireProven`. If an order contains multiple outputs and the outputs are filled by different solvers, the filler of the first output in the order specification shall be the canonical solver.

[Learn more about Input Settlement →](/architecture/input)

### Output Settlement

The output settlement scheme handles the delivery of assets on destination chains. The output settlement scheme imposes no interface requirements, order structure, or order type except that an interface to validate payloads is provided:
```solidity
interface IPayloadCreator {
    function arePayloadsValid(
        bytes[] calldata payloads
    ) external view returns (bool);
}
```
This allows the output settlement scheme to be incredible flexible, it can support any order type, on any virtual machine, as long as the filled order can be expressed as an opaque bytes array.

For simplicity, lets assume that an output can be expressed as `[token, amount, destination]`. If this output has been filled, then a valid payload could be `bytes(solver | token | amount | destination)`.

If the input settlement could validate this call, the inputs could be appropriately paid to the solver. However, this information only exists on the output settlement on the output chain.

[Learn more about Output Settlement →](/architecture/output)

### Validation Layers

The validation layer ferries valid payloads from the output chain to the input chain. It serves as the bridge that confirms fulfillment has occurred.

Any validation layer can be added to Catalyst as long as it supports validating a payload from a remote chain. Currently implemented validation layers include:

- **Wormhole** (self-serve)
- **Polymer** (self-serve)
- **Bitcoin** (self-serve)

It's expected that before making messages, the validation layer checks if one or more payloads are valid and then ship them to the input chain:
```solidity
function submit(address proofSource, bytes[] calldata payloads) external payable {
	// Check if the payloads are valid.
	if (!IPayloadCreator(proofSource).arePayloadsValid(payloads)) revert NotAllPayloadsValid();

	// Payloads are good. We can submit them on behalf of proofSource.
	_submit(proofSource, payloads);
}
```
How validator layers pass the information to the input chain is scoped. They may be using custom message encodings, custom relaying properties, custom interfaces, or other special integration concerns.

On the input chain, it is expected that the validator layer validates the payload(s) through a virtual machine local hash:
```solidity
interface IValidationLayer {
    /**
     * @notice Check if some data has been attested to.
     * @param remoteChainId Chain the data supposedly originated from.
     * @param remoteOracle Identifier for the remote attestation.
     * @param remoteApplication Identifier for the application that the attestation originated from.
     * @param dataHash Hash of data.
     */
    function isProven(uint256 remoteChainId, bytes32 remoteOracle, bytes32 remoteApplication, bytes32 dataHash) external view returns (bool);

    /**
     * @notice Check if a series of data has been attested to.
     * @dev More efficient implementation of isProven. Does not return a boolean, instead reverts if false.
     * This function returns true if proofSeries is empty.
     * @param proofSeries remoteOracle, remoteChainId, and dataHash encoded in chucks of 32*4=128 bytes.
     */
    function efficientRequireProven(
        bytes calldata proofSeries
    ) external view;
}
```

Using only the payload hash makes the system more efficient as less data is passed around.

No attempt is made at standardizing the payload. As a result, there may be incompatibilities between the input and output settlement layer. 

[Learn more about Validation Layers →](/architecture/validation)

## Sub-Calls via Catalyst

By default, Catalyst supports calls on delivery. This allows you to schedule calldata to be executed after the delivery of assets, enabling more complex cross-chain operations.

The default output type of Catalyst, called `OutputDescription`, supports secondary calls through its `remoteCall` field, allowing for additional execution logic upon delivery.

[Learn more about Sub-Calls →](/architecture/calls)

## Security Assumptions

The Catalyst system includes resource locks which create trust boundaries between key actors:

- **Sponsors** (users) trust that arbiters won't fraudulently finalize issued locks
- **Arbiters/solvers** trust allocators not to co-sign overlapping locks exceeding user deposits

No single actor can independently access funds, creating a secure environment for cross-chain transactions.

## Integration Points

Catalyst is designed to be highly composable with different components capable of being swapped out as needed:

- **Input Settlement**: New resource lock standards and standard intent interfaces can be integrated
- **Output Settlement**: New order types and fulfillment mechanisms can be added
- **Validation Layer**: Different cross-chain messaging protocols and proof layers can be supported
