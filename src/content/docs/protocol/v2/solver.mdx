---
title: "Becoming a Cross Cats solver"
description: "Cross Cats allows solvers to collect order flow to and from various VM chains and to and from Bitcoin. Compared to competing solution, capital hungry solvers can sacrafise some margin on quick payouts by using the underwriting network to their advantage."
sidebar:
  order: 8
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import GetQuotes from '../../../../components/solver/GetQuotes.svelte';

If you aren't interested in the order structure in Solidity, skip to [From Vm](#from-vm). For API documentation, refer to the [API Swagger documentation](https://catalyst-order-server-0140d799e2f7.herokuapp.com/api
).

Catalyst is ERC-7683-ish compatible. The implementation differs in 2 ways:

1. A Catalyst Order Key is returned on `initiate(...)`. For implementations that wants to verify that an order was correctly collected, this adds an option for further data validation. This change is compatible with ERC-7683 since it does not change function signatures and ERC-7683 specifies that the function has no return.
2. In the struct `Output` both the element `token` and `recipient` are encoded as `bytes32` instead of `address`. Solidity ABI encodes structs such that they fill 32 bytes. As a result, all returned objects of `ResolvedCrossChainOrder` remains compatible with implementations that assumes these are `address` (except these values are truncated).

There are 3 order structures in play.
 1. CrossChainOrder is a generic **input** order with an ERC-7683 compatible structure. Importantly, orderData contains the secret sauce and surely differs between ERC-7683 supporting implementations.
 2. ResolvedCrossChainOrder is a **output** description that roughly describes the value of a cross-chain order at a specific moment in time. It is ERC-7683 compliant* and allows solvers to easily compare resolution of order across protocols.
 3. Catalyst Order Keys are used to keep track of a Catalyst order through its **lifetime**. It contains Catalyst specific context and describes orders in depth. The hash of this struct is used to index the state progress of orders.

The generic CrossChainOrder can be seen below. `CrossChainOrder.orderData` is an ABI encoded order struct.
```solidity
struct CrossChainOrder {
    address settlementContract;
    address swapper;
    uint256 nonce;
    uint32 originChainId;
    uint32 initiateDeadline;
    uint32 fillDeadline;
    bytes orderData;
}
```

Currently, Cross-Cats supports 2 order structs: `LimitOrderData` and `DutchOrderData` for many inputs (same chain) to many outputs (different chains) and Dutch Auctions (1 to 1), respectively.
```solidity
struct LimitOrderData {
    uint32 proofDeadline;
    uint32 challengeDeadline;
    address collateralToken;
    uint256 fillerCollateralAmount;
    uint256 challengerCollateralAmount;
    address localOracle;
    bytes32 remoteOracle;
    Input[] inputs;
    Output[] outputs;
}

struct DutchOrderData {
    bytes32 verificationContext;
    address verificationContract;
    uint32 proofDeadline;
    uint32 challengeDeadline;
    address collateralToken;
    uint256 fillerCollateralAmount;
    uint256 challengerCollateralAmount;
    address localOracle;
    bytes32 remoteOracle;
    uint32 slopeStartingTime;
    int256 inputSlope;
    int256 outputSlope;
    Input input;
    Output output;
}

struct Input {
    address token;
    uint256 amount;
}

struct Output {
    bytes32 token;
    uint256 amount;
    bytes32 recipient;
    uint32 chainId;
}
```

Users will generate these order descriptions and then sign them with Permit2, generating an approval & order description with a single signature.



## From VM

Cross Cats has directionality. That means the ways orders are initiated depends on the inputs chain (where the user is swapped out of). In the current iteration, there are 2 important origin types: EVM and Bitcoin. In the future, all virtual machine chains will generally be supported in a similar manner but non-VM chains behave slightly different.

On VM chains, assets can be pulled from the user through approvals. This is not possible on non-VM chains. As a result, the order of operations is slightly different. The following section describes orders originating from a VM chain, the section [From Bitcoin](#from-bitcoin) describes orders originating from Bitcoin.

### Get Orders

The order server stores orders in their dictionary format. This allows integrators to easily parse orders and it makes the implementation highly transparent.

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript
// Lets define the 2 Order data types.
type DutchAuctionData = {
  type: "DutchAuction", // should not be submitted on-chain but can be used to differentiate order types.
  proofDeadline: number,
  challengeDeadline: number,
  collateralToken: string,
  fillerCollateralAmount: string,
  challengerCollateralAmount: string,
  localOracle: string,
  remoteOracle: string,
  slopeStartingTime: number,
  inputSlope: string,
  outputSlope: string,
  inputs: {}[], // Even though `inputs` is provided as an array, to submit on-chain it needs to be provided as a single input named `input`
  outputs: {}[]
}

type LimitOrderData = {
  type: "LimitOrder", // should not be submitted on-chain but can be used to differentiate order types.
  proofDeadline: number,
  challengeDeadline: number,
  collateralToken: string,
  fillerCollateralAmount: string,
  challengerCollateralAmount: string,
  localOracle: string,
  remoteOracle: string,
  inputs: {}[],
  outputs: {}[]
}

// Then the CrossChainOrder is defined as such:
type CrossChainOrder = {
  settlementContract: string,
  swapper: string,
  nonce: string,
  originChainId: number,
  initiateDeadline: number,
  fillDeadline: number,
  orderContext: DutchAuctionData | LimitOrderData
}

const API_URL = "https://orders.catalyst.exchange/"

type getOrderData = {
  order: CrossChainOrder,
  orderKeyHash: string | undefined, // initially but will become always defined.
  quote: {
    fromAssets: string[],
    toAssets: string[],
    toPrices: string[],
    fromPrices: string[],
    intermediary: "USD" | "EUR" | "BTC" | string,  // explicit string types here are examples.
    discount: string
  },
  signature: string,
  submitTime: number
}

type getOrdersEvent = {
  orders: getOrderData[],
  pagination: any
}

async function getOrders(): getOrdersEvent {
  const orderServerResponse = await fetch(API_URL + "orders/");
  const fetchedOrders = await orderServerResponse.json() as getOrdersEvent;

  return fetchedOrders;
}
```

</TabItem>
<TabItem label="Python">

```python
import requests

def get_orders():
    response = requests.get(API_URL + "orders/")
    fetched_orders = response.json()
    return fetched_orders
```

</TabItem>
</Tabs>

<GetQuotes client:visible/>

#### Subscribe to orders

Order subscription is WIP. We are looking for feedback as to which methods are best.

### Evaluate Orders

After fetching an order, it is expected that the solver evaluates the order. There are several helpful context pointers in the returned order, like `getOrderData.quote` which returns the price context used to price the inputs and outputs. If you trust the order server, it is sufficient to validate the quote and check that the solver supports the origin chain: `getOrderData.order.originChainId` and the outputs chains: `getOrderData.order.orderData.outputs[...].chainId`. These parameters will always be present.

Some orders may be exclusive. If `getOrderData.order.orderData.verificationContract` is defined and not `address(0)`, it will be exclusive until `getOrderData.order.orderData.slopeStartingTime`. In these cases, if they aren't exclusive to you wait until `getOrderData.order.orderData.slopeStartingTime` before initiating the order.

### Initiate Orders

After fetching and validatnig an order, it has to be submitted on-chain. Catalyst Orders arrive signed: `getOrderData.signature`. The signature is multi-use. It is a permit2 signature and allows our contracts to pull the submittor's tokens and ensures that the user approves the order. If orders are not exclusive, they are initiated on a first come first serve basis.

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript
// This tutorial uses ethersjs but you can easily replace it by similar libraries.
import {ethers} from 'ethers';

const reactorAbi = "...";
const signer = "ethers.signer..."

async function initiateOrder() {
  // Get an order
  const orders = await getOrders();
  const order = orders.orders[0];

  // Define the reactor we will call. You can get the reactor address from the order
  const reactorAddress = order.order.settlementContract;
  const reactor = new ethers.Contract(reactorAddress, reactorAbi, signer);

  // TODO: Set approvals for the reactorAddress for all inputs & collateral.

  // The order arrives almost exactly ready to use,
  // we just need to remove the type from the orderdata.
  const {type: _, ...cleanedOrderData} = order.order.orderData;
  const cleanedOrder = {...order.order, orderData: cleanedOrderData};
  const signature = order.signature;
  const fillerData = "0x"; // We will touch on the later.

  // Call the reactor to initiate the order.
  return reactor.initiate(cleanedOrder, signature, fillerData)
}
```

</TabItem>
<TabItem label="Python">

```python
from web3 import Web3

rpc_url = ""
web3 = Web3(Web3.HTTPProvider(eth_node_url))

# Your ABI and signer details
reactor_abi = "..."
signer_private_key = "your_private_key_here"
signer_address = web3.eth.account.from_key(signer_private_key).address


def initiate_order():
    # Get an order
    orders = get_orders()
    order = orders['orders'][0]

    # Define the reactor we will call. You can get the reactor address from the order
    reactor_address = order['order']['settlementContract']
    reactor = web3.eth.contract(address=reactor_address, abi=reactor_abi)

    # TODO: Set approvals for the reactorAddress for all inputs & collateral.
    # This will depend on the specific ERC20 tokens you're using,
    # you need to call approve() on the ERC20 token contracts

    # Clean the order data by removing the type field
    cleaned_order_data = order['order']['orderData'].copy()
    cleaned_order_data.pop('type')
    cleaned_order = {**order['order'], 'orderData': cleaned_order_data}
    signature = order['signature']
    filler_data = "0x" # We will touch on the later.

    # Build the transaction
    txn = reactor.functions.initiate(cleaned_order, signature, filler_data).build_transaction({
        'from': signer_address,
        'nonce': web3.eth.get_transaction_count(signer_address)
    })
    # Sign the transaction
    signed_txn = web3.eth.account.sign_transaction(txn, private_key=signer_private_key)
    # Send the transaction
    tx_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)
    # Wait for the transaction receipt
    receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
    return receipt
```

</TabItem>
</Tabs>

#### Custom FillerData & Underwriting

If `fillerData` is not provided, the input (user provided assets) will be sent to the caller. This is likely desired and as such there may be no further need to customize `fillerData`.

However, if you want to send the input to another address OR enable underwriting you need to use customized `fillerData`. Currently only 1 custom version is supposed, v1. It is structured by 1 version byte (`0x01`), `fillerAddress`, `orderPurchaseDeadline`, and `orderDiscount`:
- `fillerAddress` can be set to another address and indicates the (recipient of input assets)
- `orderPurchaseDeadline` allows someone else to buy the order before this time. Buy here means paying all of the inputs assets & potential collateral to you.
- `orderDiscount` gives buyers a small discount on the inputs. Is of `2**16-1`. To provide 1% discount: `0.01*(2**16-1)=655`. For chains with slow blocks (Bitcoin) this can be used to pay the solver using only 0-1 confirmations while assuring the user that they get high finality (6 confirmations).

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript
const fillerDataVersion = "0x01";
const fillerAddress = '0x....'.replace("0x", "");
// fillerAddress.length === 20*2;
const orderPurchaseDeadline = Number(1723199919).toString(16).padStart("0", 4*2);
//orderPurchaseDeadline.length === 4*2
const orderDiscount = Math.floor(0.01*(2**16-1)).toString(16).padStart("0", 2*2);
// orderDiscount.length === 2*2

const fillerData = fillerDataVersion + fillerAddress + orderPurchaseDeadline + orderDiscount;
```

</TabItem>
<TabItem label="Python">

```python
fillerDataVersion = "0x01";
fillerAddress = '0x....'.replace("0x", "");
# len(fillerAddress) === 20*2;
orderPurchaseDeadline = hex(1723199919).replace("0x", "").zfill(4*2);
# len(orderPurchaseDeadline) === 4*2
const orderDiscount = hex(int(0.01*(2**16-1))).replace("0x", "").zfill(2*2);
# len(orderDiscount) === 2*2

fillerData = fillerDataVersion + fillerAddress + orderPurchaseDeadline + orderDiscount;
```

</TabItem>
</Tabs>

## Delivery

Asset delivery depends on whether the destination is a VM chain or Bitcoin. For VM chains, you have to call the reactor with the appropriate configurations where for Bitcoin you just have to make any transfer that matches the provided arguments.

### EVM deliveries

Call the destination chain oracle `getOrderData.order.orderData.remoteOracle`. You can get remote chain from each output `getOrderData.order.orderData.outputs[].chainId`.

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript
// It is assumed you are continuing from the above steps.
import {ethers} from 'ethers';

const oracleAbi = "...";

// The oracle allows filling multiple outputs from different orders
// in a single transaction. They do have to go to the same chain.
// For simplicity, this function assumes that all outputs goes to
// the same chain but it may not be the case.
async function fillSingleChainOrder(order: CrossChainOrder) {
  const oracle = new ethers.Contract(order.orderData.remoteOracle, oracleAbi, signer);

  let recordedChain;
  for (const output of order.orderData.outputs) {
    if (recordedChain === undefined) recordedChain = output.chainId;
    if (recordedChain !== output.chainId)
      throw Error(`Mixed ChainIds, seen ${recordedChain} and ${output.chainId}`);
  }

  // TODO: Set approvals for the oracleAddress for the value of the output.

  // We need to provide fill times. These have to be set to proofTime.
  // These are used to ensure you can't reuse fills.
  const fillTimes = order.orderData.outputs.map(_ => order.orderData.proofDeadline);

  // Call the reactor to initiate the order.
  return oracle.fill(outputs, fillTimes);
}
```

</TabItem>
<TabItem label="Python">

```python
# It is assumed you are continuing from the above steps.

oracleAbi = "...";

# The oracle allows filling multiple outputs from different orders in a single transaction.
# They do have to go to the same chain.
# For simplicity, this function assumes that all outputs goes to the same chain but it may not be the case.
def fill_single_chain_order(order):
    oracle_address = order['orderData']['remoteOracle']
    oracle = web3.eth.contract(address=oracle_address, abi=oracle_abi)

    recordedChain = "";
    for (output in order['orderData']['outputs']):
      if (recordedChain == ""):
        recordedChain = output.chainId
      if (recordedChain != output.chainId):
        raise Exception(f"Mixed ChainIds, seen {recordedChain} and {output.chainId}");

    # TODO: Set approvals for the oracleAddress for the value of the output.


    # We need to provide fill times. These have to be set to proofTime.
    # These are used to ensure you can't reuse fills.
    fillTimes = [order.orderData.proofDeadline for _ in order.orderData.outputs]

    # Build the transaction
    txn = oracle.functions.fill(order.orderData.outputs, fillTimes).build_transaction({
        'from': signer_address,
        'nonce': web3.eth.get_transaction_count(signer_address)
    })
    # Sign the transaction
    signed_txn = web3.eth.account.sign_transaction(txn, private_key=signer_private_key)
    # Send the transaction
    tx_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)
    # Wait for the transaction receipt
    receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
    return receipt
```

</TabItem>
</Tabs>

### Bitcoin Deliveries

To identify whether an order contains a Bitcoin transaction, check the output token: `getOrderData.order.orderData.outputs[].token`. If the output is Bitcoin, the following must hold:
- The first 12 bytes can be anything and are not read.
- The 13'th byte (or 20'th from right) must be 0xBB.
- Byte 14 through 30 must be 0.
- Byte The 2 bytes 31 and 32 contains an address version identifier. Decode as uint16.

If the transaction is to Bitcoin, the address (`getOrderData.order.orderData.outputs[].recipient`) will contain the relevant hash or witness.

<table>
  <thead>
    <tr>
      <th>Version</th>
      <th>Name</th>
      <th>Encoding Scheme</th>
      <th>Prefix</th>
    </tr>
  </thead>
  <tbody>
  <tr>
    <td>0</td>
    <td>Unknown</td>
    <td>Ignore</td>
    <td></td>
  </tr>
  <tr>
    <td>1</td>
    <td>P2PKH</td>
    <td>Base58Check(00+PKH)</td>
    <td>1*</td>
  </tr>
  <tr>
    <td>2</td>
    <td>P2SH</td>
    <td>Base58Check(05+SH)</td>
    <td>3*</td>
  </tr>
  <tr>
    <td>3</td>
    <td>P2WPKH</td>
    <td>Bech32</td>
    <td>b1cq</td>
  </tr>
  <tr>
    <td>4</td>
    <td>P2WSH</td>
    <td>Bech32</td>
    <td>b1cq</td>
  </tr>
  <tr>
    <td>5</td>
    <td>P2TR</td>
    <td>Bech32m</td>
    <td>b1cp</td>
  </tr>
  </tbody>
</table>
*Not true prefixes since the prefix is determined by the encoding.

The below tutorials assume that you are implementing this from the perspective of a solver. As a result, you are interested in converting an expected output script into a Bitcoin address that can be provided to your wallet.

- **P2PKH**. The recipient is the public key hash. The script hash needs to be encoded with [Base58Check](https://rosettacode.org/wiki/Base58Check_encoding). Select the first 20 bytes and prepend with 00. Encode with Base58Check.
- **P2SH**. The recipient is the script hash. The script hash needs to be encoded with [Base58Check](https://rosettacode.org/wiki/Base58Check_encoding). Select the first 20 bytes and prepend with 05. Encode with Base58Check.
- **P2WPKH**. The recipient is the witness. The witness needs to be encoded with [Bech32](https://github.com/bitcoinjs/bech32). Select the first 20 bytes. Encode with Bech32. Prepend with bc1q.
- **P2WSH**. The recipient is the witness hash. The witness hash needs to be encoded with [Bech32](https://github.com/bitcoinjs/bech32). Select the first 32 bytes. Encode with Bech32. Prepend with bc1q.
- **P2WTR**. The recipient is the witness hash. The witness hash needs to be encoded with [Bech32m](https://en.bitcoin.it/wiki/BIP_0350#Bech32m). Select the first 32 bytes. Encode with Bech32m. Prepend with bc1p.

Once the address is generate, make a transaction that has an **exact** output that matches any outputs from the initiated order. There is no limit as to how the transaction is organised, it may have any inputs and outputs as long as one output matched exactly the one described by the order's output. This allows for transaction flexibility like batch filling, consolidation, and more.

## From Bitcoin

### Quote Open Order

Unlike for VM, to solve Bitcoin to EVM orders you need to be able to submit quotes to the UI. The UI may request a quote from you.

TODO: Some endpoint that includes an approximate quote.

### Return Signed Orders

TODO: If you are chosen to be the solver for the Bitcoin to VM order, you need to generate a signed order. This works opposite of the flow for VM chains where the user would be the one signing orders. This may seem riskier but don't worry. We will make the order exclusive to the user & the UI's executor. This is important since the Cross Cats UI can guarantee that the assets will be delivered through a UI controlled but user owned Bitcoin address.

## Prove Orders

If a Solvers' orders get challenged, they need to prove delivery. In exchange for these proofs, Solvers collect the collateral provided by Challengers.


## Challenger

Challengers work to ensure that solvers stay honest. Solvers submit collateral when claiming transaction. If Solvers aren't honest, Challengers can claim the collateral if they prove that Solvers havn't done settled their claimed orders.


## Broadcast Orders

The first step of any order is broadcasting it. For solvers this can be seen as the 0'th step, since it is required before solvers can collect the orders from the order server.

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript

async function submitOrder(): bool {
  const order: CrossChainorder;
  const signature: string;
  const body = {
    order,
    signature
  };
  const response = await fecth(API_URL + "orders/submit", {
    method: 'POST',
    body
  });
  const parsedResponse = await response.json() as { success: bool };

  return parsedResponse.success;
}
```

</TabItem>
<TabItem label="Python">

```python
import requests
import json

API_URL = "https://orders.catalyst.exchange/"

def submit_order(): bool:
    order = {}
    signature = "0x..."
    data = {
      "order": order,
      "signature": signature
    }
    response = requests.post(API_URL+ "orders/submit", json=data)
    fetched_orders = response.json()
    return fetched_orders.get("success")
```

</TabItem>
</Tabs>
