---
title: "Becoming a Cross Cats solver"
description: "Cross Cats allows solvers to collect order flow to and from various VM chains and to and from Bitcoin. Compared to competing solution, capital hungry solvers can sacrafise some margin on quick payouts by using the underwriting network to their advantage."
sidebar:
  order: 8
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import GetQuotes from '../../../../components/solver/GetQuotes.svelte';

If you aren't interested in the order structure in Solidity, skip to [From VM](#from-evm). For API documentation, refer to the [API Swagger documentation](https://catalyst-order-server-0140d799e2f7.herokuapp.com/api
).

Catalyst is [ERC-7683](https://www.erc7683.org)* compatible. *The implementation differs in 2 ways:

1. A Catalyst [OrderKey](https://github.com/catalystdao/cross-cats/blob/7e07281eef10ffadc10f9f75eb42d1c2419224ca/src/interfaces/Structs.sol#L41-L65) is returned on `initiate(...)`. For implementations that wants to verify that orders were correctly collected, this adds options for further data validation. This change is compatible with ERC-7683 since it does not change any function signatures and ERC-7683 specifies that the function has no return.
2. ERC-7683 defines the 2 elements of `Output`, `token` and `recipient` to be type `address`. The type of both elements have been changed to `bytes32`. Solidity ABI encoding encodes structs elements such that they fill 32 bytes. As a result, all returned objects of `ResolvedCrossChainOrder` remains compatible with implementations that assumes these are `address` (except these values are truncated).

Cross Cats uses 3 order structures:
 1. [CrossChainOrder](https://github.com/catalystdao/cross-cats/blob/7e07281eef10ffadc10f9f75eb42d1c2419224ca/src/interfaces/ISettlementContract.sol#L6-L27) is a generic **input** order with an ERC-7683 compatible structure. Importantly, orderData contains the secret sauce and surely differs between ERC-7683 supporting implementations.
 2. [ResolvedCrossChainOrder](https://github.com/catalystdao/cross-cats/blob/7e07281eef10ffadc10f9f75eb42d1c2419224ca/src/interfaces/ISettlementContract.sol#L29-L52) is a **quote** description that describes the value of a cross-chain order at a specific moment in time. It is ERC-7683 compliant* and allows solvers to easily compare resolution of order across protocols.
 3. Catalyst [OrderKey](https://github.com/catalystdao/cross-cats/blob/7e07281eef10ffadc10f9f75eb42d1c2419224ca/src/interfaces/Structs.sol#L41-L65) are used to keep track of a Catalyst order through its **lifetime**. It contains Catalyst specific context and describes orders in depth. The hash of this struct is used to index the state progress of orders.

The generic CrossChainOrder can be seen below. `CrossChainOrder.orderData` is an ABI encoded order struct.
```solidity
struct CrossChainOrder {
    address settlementContract;
    address swapper;
    uint256 nonce;
    uint32 originChainId;
    uint32 initiateDeadline;
    uint32 fillDeadline;
    bytes orderData;
}
```

Currently, Cross-Cats supports 2 order structs:
```solidity
/// @notice Supports many inputs (same chain) to many outputs (different chains)
struct LimitOrderData {
    uint32 proofDeadline;
    uint32 challengeDeadline;
    address collateralToken;
    uint256 fillerCollateralAmount;
    uint256 challengerCollateralAmount;
    address localOracle;
    bytes32 remoteOracle;
    Input[] inputs;
    Output[] outputs;
}
/// @notice Supports Dutch Auctions on both input and output (1 to 1).
struct DutchOrderData {
    bytes32 verificationContext;
    address verificationContract;
    uint32 proofDeadline;
    uint32 challengeDeadline;
    address collateralToken;
    uint256 fillerCollateralAmount;
    uint256 challengerCollateralAmount;
    address localOracle;
    bytes32 remoteOracle;
    uint32 slopeStartingTime;
    int256 inputSlope;
    int256 outputSlope;
    Input input;
    Output output;
}

// With the input and output struct defined as:
struct Input {
    address token;
    uint256 amount;
}
struct Output {
    bytes32 token;
    uint256 amount;
    bytes32 recipient;
    uint32 chainId;
}
```

Users will generate a `CrossChainOrder` with the appropriate order data and sign them with Permit2, generating an approval & order description with a single signature. The signed struct with be a new struct where `
orderData` will be of the order type struct.

## From EVM

Cross Cats has directionality. That means the ways orders are initiated depends on the initiating chain (where the user is swapping out of). In the current iteration, there are 2 important origin types: EVM and Bitcoin. In the future, all virtual machine chains (including EVM) will generally be initiated in a similarly and all non-VM chains (including Bitcoin) will be initiated in a similarly but different from VM chains.

On VM chains, assets can be pulled from the user through approvals. This is not possible on non-VM chains. As a result, the order of operations is slightly different. The following section describes orders originating from a VM chain, the section [From Bitcoin](#from-bitcoin) describes orders originating from Bitcoin.

### Get Orders

The order server stores orders in their dictionary format. This allows integrators to easily parse orders and it makes the implementation highly transparent.

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript
// Lets define the 2 Order data types.
type DutchAuctionData = {
  type: "DutchAuction", // should not be submitted on-chain but can be used to differentiate order types.
  proofDeadline: number,
  challengeDeadline: number,
  collateralToken: string,
  fillerCollateralAmount: string,
  challengerCollateralAmount: string,
  localOracle: string,
  remoteOracle: string,
  slopeStartingTime: number,
  inputSlope: string,
  outputSlope: string,
  inputs: {}[], // Even though `inputs` is provided as an array, to submit on-chain it needs to be provided as a single input named `input`
  outputs: {}[]
}

type LimitOrderData = {
  type: "LimitOrder", // should not be submitted on-chain but can be used to differentiate order types.
  proofDeadline: number,
  challengeDeadline: number,
  collateralToken: string,
  fillerCollateralAmount: string,
  challengerCollateralAmount: string,
  localOracle: string,
  remoteOracle: string,
  inputs: {}[],
  outputs: {}[]
}

// Then the CrossChainOrder is defined as such:
type CrossChainOrder = {
  settlementContract: string,
  swapper: string,
  nonce: string,
  originChainId: number,
  initiateDeadline: number,
  fillDeadline: number,
  orderContext: DutchAuctionData | LimitOrderData
}

const API_URL = "https://orders.catalyst.exchange/"

type GetOrderData = {
  order: CrossChainOrder,
  orderKeyHash: string | undefined, // initially but will become always defined.
  quote: {
    fromAssets: string[],
    toAssets: string[],
    toPrices: string[],
    fromPrices: string[],
    intermediary: "USD" | "EUR" | "BTC" | string,  // explicit string types here are examples.
    discount: string
  },
  signature: string,
  submitTime: number
}

type GetOrdersEvent = {
  orders: GetOrderData[],
  pagination: any
}

async function getOrders(): GetOrdersEvent {
  const orderServerResponse = await fetch(API_URL + "orders/");
  const fetchedOrders = await orderServerResponse.json() as GetOrdersEvent;

  return fetchedOrders;
}
```

</TabItem>
<TabItem label="Python">

```python
import requests

def get_orders():
    response = requests.get(API_URL + "orders/")
    fetched_orders = response.json()
    return fetched_orders
```

</TabItem>
</Tabs>

<GetQuotes client:load/>

#### Subscribe to orders (WIP)

This section is heavily work in progress and is very likely to be significantly changed. We are very open to feedback and exploring alternatives.

As an alternative to polling orders, you can also subscribe to new orders. The Catalyst order server exposes a websocket endpoint that broadcasts new orders as they arrive. This significantly decreases latency at the cost of increased complexity.

Unlike the API endpoint, orders delivered over the websocket connected are not filterable. It is assumed that the consumer will filter orders locally.

### Evaluate Orders

After fetching an order, it is expected that the solver evaluates the order. There are several helpful context pointers in the returned order, like `GetOrderData.quote` which returns the price context used to price the inputs and outputs. If you trust the order server, it is sufficient to validate the quote and check that the solver supports the origin chain: `GetOrderData.order.originChainId` and the outputs chains: `GetOrderData.order.orderData.outputs[...].chainId` along with their respective tokens `input|output[].token` These parameters will always be present regardless of order type.

Some orders may be exclusive. If `GetOrderData.order.orderData.verificationContract` is defined and not `address(0)`, it will be exclusive until `GetOrderData.order.orderData.slopeStartingTime`. In these cases, if they aren't exclusive to you wait until `GetOrderData.order.orderData.slopeStartingTime` before initiating the order.

### Initiate Orders

After fetching and validatnig an order, it has to be submitted on-chain. Catalyst Orders arrive signed: `GetOrderData.signature`. The signature is multi-purpose. It is a permit2 signature and allows our contracts to pull the submittor's tokens and ensures that the user approves of the order. If an order is not exclusive, it will be initiated on a first come first serve basis.

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript
// This tutorial uses ethersjs but you can easily replace it by similar libraries.
import {ethers} from 'ethers';

const reactorAbi = "...";
const signer = "ethers.signer..."

async function initiateOrder() {
  // Get an order
  const orders = await getOrders();
  const order = orders.orders[0];

  // Define the reactor we will call. You can get the reactor address from the order
  const reactorAddress = order.order.settlementContract;
  const reactor = new ethers.Contract(reactorAddress, reactorAbi, signer);

  // TODO: Set approvals for the reactorAddress for all inputs & collateral.

  // The order arrives almost ready to use,
  // we just need to remove the type from the orderdata.
  const {type: _, ...cleanedOrderData} = order.order.orderData;
  const cleanedOrder = {...order.order, orderData: cleanedOrderData};
  const signature = order.signature;
  const fillerData = "0x"; // #custom-fillerdata--underwriting

  // Call the reactor to initiate the order.
  return reactor.initiate(cleanedOrder, signature, fillerData)
}
```

</TabItem>
<TabItem label="Python">

```python
from web3 import Web3

rpc_url = ""
web3 = Web3(Web3.HTTPProvider(eth_node_url))

# Your ABI and signer details
reactor_abi = "..."
signer_private_key = "your_private_key_here"
signer_address = web3.eth.account.from_key(signer_private_key).address

def initiate_order():
    # Get an order
    orders = get_orders()
    order = orders['orders'][0]

    # Define the reactor we will call. You can get the reactor address from the order
    reactor_address = order['order']['settlementContract']
    reactor = web3.eth.contract(address=reactor_address, abi=reactor_abi)

    # TODO: Set approvals for the reactorAddress for all inputs & collateral.
    # This will depend on the specific ERC20 tokens you're using,
    # you need to call approve() on the ERC20 token contracts

    # Clean the order data by removing the type field
    cleaned_order_data = order['order']['orderData'].copy()
    cleaned_order_data.pop('type')
    cleaned_order = {**order['order'], 'orderData': cleaned_order_data}
    signature = order['signature']
    filler_data = "0x" # #custom-fillerdata--underwriting

    # Build the transaction
    txn = reactor.functions.initiate(cleaned_order, signature, filler_data).build_transaction({
        'from': signer_address,
        'nonce': web3.eth.get_transaction_count(signer_address)
    })
    # Sign the transaction
    signed_txn = web3.eth.account.sign_transaction(txn, private_key=signer_private_key)
    # Send the transaction
    tx_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)
    # Wait for the transaction receipt
    receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
    return receipt
```

</TabItem>
</Tabs>

#### Custom FillerData & Underwriting

If `fillerData` is not provided, the input (user provided assets) will be sent to the caller. This is likely desired and as such there may be no further need to customize `fillerData`.

However, if you want to send the input to another address OR enable underwriting you need to use customized `fillerData`. Currently only 1 custom version is supported: v1. It is structured by 1 version byte (`0x01`), `fillerAddress`, `orderPurchaseDeadline`, and `orderDiscount`:
- `fillerAddress` is the recipient of the input assets & collateral.
- `orderPurchaseDeadline` allows someone else to buy the order before this time. Buy here means paying all of the inputs assets & collateral to `fillerAddress`.
- `orderDiscount` gives buyers a small discount on the inputs. Is of `2**16-1`. To provide 1% discount: `0.01*(2**16-1)=655`. For chains with slow blocks (Bitcoin) this can be used to pay the solver after 0-1 confirmations while ensuring the user that they get high finality (3-6 confirmations).

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript
const fillerDataVersion = "0x01";
const fillerAddress = '0x....'.replace("0x", "");
// fillerAddress.length === 20*2;
const orderPurchaseDeadline = Number(1723199919).toString(16).padStart("0", 4*2);
//orderPurchaseDeadline.length === 4*2
const orderDiscount = Math.floor(0.01*(2**16-1)).toString(16).padStart("0", 2*2);
// orderDiscount.length === 2*2

const fillerData = fillerDataVersion + fillerAddress + orderPurchaseDeadline + orderDiscount;
```

</TabItem>
<TabItem label="Python">

```python
fillerDataVersion = "0x01";
fillerAddress = '0x....'.replace("0x", "");
# len(fillerAddress) === 20*2;
orderPurchaseDeadline = hex(1723199919).replace("0x", "").zfill(4*2);
# len(orderPurchaseDeadline) === 4*2
const orderDiscount = hex(int(0.01*(2**16-1))).replace("0x", "").zfill(2*2);
# len(orderDiscount) === 2*2

fillerData = fillerDataVersion + fillerAddress + orderPurchaseDeadline + orderDiscount;
```

</TabItem>
</Tabs>

## Delivery

Asset delivery depends on whether the destination is a VM chain or Bitcoin. For VM chains, you have to call the reactor with the appropriate configurations where for Bitcoin you just have to make any transfer that matches the provided arguments.

### EVM deliveries

Call the destination chain oracle `GetOrderData.order.orderData.remoteOracle`. You can get remote chain from each output `GetOrderData.order.orderData.outputs[].chainId`.

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript
// It is assumed you are continuing from the above steps.
import {ethers} from 'ethers';

const oracleAbi = "...";

// The oracle allows filling multiple outputs from different orders
// in a single transaction. They do have to go to the same chain.
// For simplicity, this function assumes that all outputs goes to
// the same chain but it may not be the case.
async function fillSingleChainOrder(order: CrossChainOrder) {
  const oracle = new ethers.Contract(order.orderData.remoteOracle, oracleAbi, signer);

  let recordedChain;
  for (const output of order.orderData.outputs) {
    if (recordedChain === undefined) recordedChain = output.chainId;
    if (recordedChain !== output.chainId)
      throw Error(`Mixed ChainIds, seen ${recordedChain} and ${output.chainId}`);
  }

  // TODO: Set approvals for the oracleAddress for the value of the output.

  // We need to provide fill times. These have to be set to proofTime.
  // These are used to ensure you can't reuse fills.
  const fillTimes = order.orderData.outputs.map(_ => order.orderData.proofDeadline);

  // Call the reactor to initiate the order.
  return oracle.fill(outputs, fillTimes);
}
```

</TabItem>
<TabItem label="Python">

```python
# It is assumed you are continuing from the above steps.

oracleAbi = "...";

# The oracle allows filling multiple outputs from different orders in a single transaction.
# They do have to go to the same chain.
# For simplicity, this function assumes that all outputs goes to the same chain but it may not be the case.
def fill_single_chain_order(order):
    oracle_address = order['orderData']['remoteOracle']
    oracle = web3.eth.contract(address=oracle_address, abi=oracle_abi)

    recordedChain = "";
    for (output in order['orderData']['outputs']):
      if (recordedChain == ""):
        recordedChain = output.chainId
      if (recordedChain != output.chainId):
        raise Exception(f"Mixed ChainIds, seen {recordedChain} and {output.chainId}");

    # TODO: Set approvals for the oracleAddress for the value of the output.


    # We need to provide fill times. These have to be set to proofTime.
    # These are used to ensure you can't reuse fills.
    fillTimes = [order.orderData.proofDeadline for _ in order.orderData.outputs]

    # Build the transaction
    txn = oracle.functions.fill(order.orderData.outputs, fillTimes).build_transaction({
        'from': signer_address,
        'nonce': web3.eth.get_transaction_count(signer_address)
    })
    # Sign the transaction
    signed_txn = web3.eth.account.sign_transaction(txn, private_key=signer_private_key)
    # Send the transaction
    tx_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)
    # Wait for the transaction receipt
    receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
    return receipt
```

</TabItem>
</Tabs>

### Bitcoin Deliveries

To identify whether an order contains a Bitcoin transaction, check the output token: `GetOrderData.order.orderData.outputs[].token`. If the output is Bitcoin, the following must hold:
- The first 30 bytes should be equal to `0x000000000000000000000000BB0000000000000000000000000000000000`. Notice the 13'th byte is `0xBB`.
- The 31'th byte is reserved and not checked.
- The 32'th byte contains an address version identifier. Decode as uint8.

If the transaction is to Bitcoin, the address (`GetOrderData.order.orderData.outputs[].recipient`) will contain the relevant destination hash or witness which is not the address!

<table>
  <thead>
    <tr>
      <th>Version</th>
      <th>Name</th>
      <th>Encoding Scheme</th>
      <th>Prefix</th>
      <th>Hash Length</th>
    </tr>
  </thead>
  <tbody>
  <tr>
    <td>0</td>
    <td>Unknown</td>
    <td>Ignore</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>1</td>
    <td>P2PKH</td>
    <td>Base58Check(00+PKH)</td>
    <td>1*</td>
    <td>20</td>
  </tr>
  <tr>
    <td>2</td>
    <td>P2SH</td>
    <td>Base58Check(05+SH)</td>
    <td>3*</td>
    <td>20</td>
  </tr>
  <tr>
    <td>3</td>
    <td>P2WPKH</td>
    <td>Bech32</td>
    <td>b1cq</td>
    <td>20</td>
  </tr>
  <tr>
    <td>4</td>
    <td>P2WSH</td>
    <td>Bech32</td>
    <td>b1cq</td>
    <td>32</td>
  </tr>
  <tr>
    <td>5</td>
    <td>P2TR</td>
    <td>Bech32m</td>
    <td>b1cp</td>
    <td>32</td>
  </tr>
  </tbody>
</table>
*Not true prefixes since the prefix is determined by the encoding.

The below tutorials assume that you are implementing this from the perspective of a solver. As a result, you are interested in converting an expected output script into a Bitcoin address that can be provided to your wallet.

- **P2PKH**. The recipient is the public key hash. The public key hash needs to be encoded with [Base58Check](https://rosettacode.org/wiki/Base58Check_encoding). Select the first 20 bytes and prepend with 00. Encode with Base58Check.
- **P2SH**. The recipient is the script hash. The script hash needs to be encoded with [Base58Check](https://rosettacode.org/wiki/Base58Check_encoding). Select the first 20 bytes and prepend with 05. Encode with Base58Check.
- **P2WPKH**. The recipient is the witness. The witness needs to be encoded with [Bech32](https://github.com/bitcoinjs/bech32). Select the first 20 bytes. Encode with Bech32. Prepend with bc1q.
- **P2WSH**. The recipient is the witness hash. The witness hash needs to be encoded with [Bech32](https://github.com/bitcoinjs/bech32). Select the first 32 bytes. Encode with Bech32. Prepend with bc1q.
- **P2WTR**. The recipient is the witness hash. The witness hash needs to be encoded with [Bech32m](https://en.bitcoin.it/wiki/BIP_0350#Bech32m). Select the first 32 bytes. Encode with Bech32m. Prepend with bc1p.

Nested witness outputs are **P2SH**.

Once the address is generated, make a transaction that has 1 **exact** output that matches the relevant output from the initiated order. There is no limit as to how the transaction is organised, it may have any inputs and outputs as long as one output matched exactly the one described by the order's output. This allows for transaction flexibility like batch filling, consolidation, and more.

## From Bitcoin

While Bitcoin has scripts, Bitcoin scripts only contains spending conditions so unlike a VM chain, we can't pull funds from the user after a signed message. As a result, the order flow is flipped and the solver signed the VM order.
While it is technically possible to create unique conditional deposits addresses, no wallets support custom scripts.

#### Encoding a Bitcoin Address

Your solver needs to be able to generate a Bitcoin deposit address. It is technically possible to use the same address for every single order. If you do this, it is very important that the amounts are unique for every single order. It is recommended to use different addresses for every order. Bitcoin does not charge extra to collect UTXOs from different addresses.

The Bitcoin address is encoded in 2 fields: `token` and `address`. The token field is used to block tokens from filling Bitcoin orders and to encode the address version. See this [table](#bitcoin-deliveries) for converting address types to versions.

The `address` is used to encode either the public key hash, script hash, or witness hash. The table mentioned above contains the encoding schemes for various Bitcoin address versions. Hashes of 20 bytes (P2PKH, P2SH, and P2WPKH) should be padded with 0s on the right side. (`0xabcdef...00000`)

### Quote Open Order (WIP)

Solvers for BTC to VM needs to be able to quote orders for comparison with other solvers. To start quoting, solvers needs to subscribe to requests quote from the order server. Upon requests for quotes, the solver needs to respond with a quote. The quote needs to be valid for at least 60 seconds. (30 second quote life, 30 order life)

If a quote is issued, the solver needs to be able to respond with a signed order. If the solver doesn't respond with the same (or better) order when the order is requested within 30 seconds, the solver may be blacklisted.

```typescript
// TODO: make this proper logic rather than pseudo-logic.
const websocketServer;
// 1. Define an evaluation logic. This evaluation logic may
// be as simple as either accepting or rejecting the order
// based on the reference rate.
function orderEvaluations(order: any): any | undefined {...}
// 2. Subscribe to the Quotes
websocketServer.onRequestForQuote((order) => {
  const quoted = orderEvaluations(order);
  if (quoted !== undefined)
    // 3. Respond to the request for quote.
    websocketServer.respond(quoted);
});
```

### Return Signed Orders (WIP)

The UI compares all received quotes from solvers and chooses the quote from the best solver. Once the user's deposit is confirmed, the UI requests the solver for a signed order. The signer has to send back a signed order that matches with quote given (within expiry). It is important that the returned order is exclusive to the user & the UI's executor (see code). This is important since the Cross Cats UI can guarantee that the assets will be delivered through a UI controlled but user owned Bitcoin address.

```typescript
const websocketServer;
// 1. We need to sign the order request.
// Importantly, we also need to validate that this is a valid
// request.
function signOrderRequest(signOrderRequest: any): any | undefined {
  const evaluationResponse = orderEvaluations(signOrderRequest);
  if (evaluationResponse === undefined) return undefined;
  ...
}
// 2. Listen to request for signed orders
websocketServer.onRequestForOrder((request) => {
  const signedOrder = signOrderRequest(order);
  if (quoted === undefined) {
    // 3. Respond to the request for quote.
    websocketServer.respond("no");
  } else {
    websocketServer.respond(signedOrder);
  }
});
```

Once the signedOrder is sent & it correctly matches the expected quote, the vast vast majority of orders will be filled.

TODO: The UI may respond back with a transaction hash.

## Prove Orders (WIP)

If Solvers' orders get challenged, they need to prove delivery. In exchange for these proofs, Solvers collect the collateral provided by Challengers.

Initially, Cata Labs will prove every single order for completeness.


## Challenger

Challengers work to ensure that solvers stay honest. Solvers submit collateral when claiming transaction. If Solvers aren't honest, Challengers can claim the collateral if they prove that Solvers havn't done settled their claimed orders.

Initially, Cata Labs will prove every single order for completeness.

## Broadcast Orders

The first step of any order is broadcasting it. For solvers this can be seen as the 0'th step, since it is required before solvers can collect the orders from the order server.

:::tip[Proof of Work]
Submitting orders can easily be used to DDoS the order server. As a protection, the order server requires submitting a piece of PoW to rate-limit submissions.
:::

<Tabs syncKey="lang">
<TabItem label="Typescript">

```typescript

async function submitOrder(): bool {
  const order: CrossChainorder;
  const signature: string;
  const body = {
    order,
    signature
  };
  const response = await fecth(API_URL + "orders/submit", {
    method: 'POST',
    body
  });
  const parsedResponse = await response.json() as { success: bool };

  return parsedResponse.success;
}
```

</TabItem>
<TabItem label="Python">

```python
import requests
import json

API_URL = "https://orders.catalyst.exchange/"

def submit_order(): bool:
    order = {}
    signature = "0x..."
    data = {
      "order": order,
      "signature": signature
    }
    response = requests.post(API_URL+ "orders/submit", json=data)
    fetched_orders = response.json()
    return fetched_orders.get("success")
```

</TabItem>
</Tabs>
