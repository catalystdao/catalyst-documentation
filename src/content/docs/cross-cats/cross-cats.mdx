---
title: "Cross Cats: Solving Liquidity x Bitcoin"
description: "Catalyst v2 will support Bitcoin swaps. This is facilitated through intent based swaps that are verified through an on-chain Bitcoin SPV client. This provides: Fast settlement, Competitive rates, and near full security."
sidebar:
  order: 1
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Cross-Cats is an intent-based cross-chain swap protocol built with flexibility in mind. The core idea is to allow anyone to create a request for anything provable. At launch, EVM settlements and Bitcoin transactions will be part of the provable set. Bitcoin transactions are proven using a Bitcoin SPV client and allows VM chain payments to be conditional on Bitcoin transactions.
<Tabs>
  <TabItem label="Index">
    ```d2 target=root
      style.fill: transparent
      direction: right

      vars: {
        default-opacity: 0.1
      }

      title: System Overview {
        near: top-center
        shape: text
        style: {
          font-size: 40
        }
      }

      Order Server: {shape: cloud}

      Source Chain: {
        User: {
          shape: person
        }
        Solver: {
          style.fill-pattern: none
        }
        Reactor: {shape: page}
        Oracle: {
          style.opacity: ${default-opacity}
          shape: page
        }
        Challenger: {style.opacity: ${default-opacity}}
        SPV: {
          style.opacity: ${default-opacity}
          shape: page
        }

        Solver -> Reactor: 3. resolve() => Quote
        Solver -> Reactor: 4.1. initiate()
        User -> Reactor: 4.2. Tokens

        # Optimistic Payout
        Solver <-> Reactor: O.6.1. optimisticPayout() {style.opacity: ${default-opacity}}

        # Challenge Parts
        Challenger -> Reactor: C.6.1. dispute() {style.opacity: ${default-opacity}}

        # - Challenged Rejected (VM)
        Oracle -> Reactor: C.9.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
        Reactor -> Solver: C.9.3. payout Tokens {style.opacity: ${default-opacity}}

        # - Challenged Rejected (Bitcoin)
        Solver -> SPV: C.7.1. verify() {style.opacity: ${default-opacity}}
        SPV -> Reactor: C.7.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
        Reactor -> Solver: C.7.3. payout Tokens {style.opacity: ${default-opacity}}

        # - Challenged Accepted
        Challenger -> Reactor: C.7.1. completeDispute() {style.opacity: ${default-opacity}}
        Reactor -> Challenger: C.7.2. Reward {style.opacity: ${default-opacity}}
        Reactor -> User: C.7.3. Tokens {style.opacity: ${default-opacity}}
      }

      Source Chain.User -> Order Server: 1. Sign Message {style.animated: false}
      Order Server -> Source Chain.Solver: 2. Signed Orders

      Destination Chain: {
        Oracle: {
          shape: page
        }
        Solver
        SPV: {
          style.opacity: ${default-opacity}
          shape: page
        }
        User: {
          shape: person
        }

        # Ordinary
        Solver -> Oracle: 5.1. fill()
        Solver -> User: 5.2. Tokens

        # Challenged submit proof (VM)
        Solver -> Oracle: C.7.1. submit() {style.opacity: ${default-opacity}}

        # Challenged submit proof (Bitcoin)
        Solver -> SPV: C.7.1: verify() {style.opacity: ${default-opacity}}
        SPV -> Oracle: C.7.2. Send fill details {style.opacity: ${default-opacity}}
      }

      Bitcoin: {
        Solver: {
          style.opacity: ${default-opacity}
        }
        User: {
          shape: person
          style.opacity: ${default-opacity}
        }

        Solver -> User: 5.1 transfer {style.opacity: ${default-opacity}}
        style.opacity: ${default-opacity}
      }

      Bitcoin -> Destination Chain.SPV: Bitcoin Headers {
        style.opacity: ${default-opacity}
        style.stroke-dash: 4
      }
      Bitcoin -> Source Chain.SPV: Bitcoin Headers {
        style.opacity: ${default-opacity}
        style.stroke-dash: 4
      }

      Proof: "AMB\n" {
        shape: cloud
        style.opacity: ${default-opacity}
      }

      Destination Chain.Oracle -> Proof: C.8.1. Collect event {style.opacity: ${default-opacity}}
      Proof -> Source Chain.Oracle: C.9.1. receiveMessage() {style.opacity: ${default-opacity}}

      scenarios: {
        optimistic resolution: {
          title.label: Optimistic Resolution
          Source Chain: {
            (Solver <-> Reactor)[0].style.opacity: 1

            (Solver <-> Reactor)[0].style.stroke-width: 3
          }
        }
        challenged: {
          title.label: Challenged
          Source Chain.Challenger.style.opacity: 1
          Source Chain.(Challenger -> Reactor)[0].style.opacity: 1
          Source Chain.(Challenger -> Reactor)[0]: C.6.1. dispute()

          Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 3

          scenarios: {
            challenged uncontested: {
              title.label: Challenged Uncontested
              Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
              Source Chain.(Challenger -> Reactor)[1].style.opacity: 1
              Source Chain.(Challenger -> Reactor)[1]: C.7.1. completeDispute()

              Source Chain.(Challenger -> Reactor)[1].style.stroke-width: 3
              Source Chain.(Reactor -> Challenger)[0].style.opacity: 1
              Source Chain.(Reactor -> User)[0].style.opacity: 1
              Destination Chain.style.opacity: ${default-opacity}
              Destination Chain.*.style.opacity: ${default-opacity}
              Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
            }
            order fill proven (VM): {
              title.label: Order Fill Proven (VM)
              Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2

              Destination Chain.(Solver -> Oracle)[1].style.opacity: 1
              Destination Chain.(Solver -> Oracle)[1].style.stroke-width: 3
              Destination Chain.Oracle.style.opacity: 1
              Proof.style.opacity: 1
              (Destination Chain.Oracle -> Proof)[0].style.opacity: 1
              (Proof -> Source Chain.oracle)[0].style.opacity: 1
              Source Chain.Oracle.style.opacity: 1
              Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
              Source Chain.(Reactor -> Solver)[0].style.opacity: 1
            }
            order fill proven (BTC): {
              Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
              Destination Chain.style.opacity: ${default-opacity}
              Destination Chain.*.style.opacity: ${default-opacity}
              Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
              Bitcoin.style.opacity: 1
              Bitcoin.*.style.opacity: 1
              Bitcoin.(* -> *)[*].style.opacity: 1

              scenarios: {
                local SPV client: {
                  title.label: Local SPV Client
                  (Bitcoin -> Source Chain.SPV)[0].style.opacity: 1
                  Source Chain.SPV.style.opacity: 1

                  Source Chain.(Solver -> SPV)[0].style.opacity: 1
                  Source Chain.(Solver -> SPV)[0].style.stroke-width: 3
                  Source Chain.(SPV -> Reactor)[0].style.opacity: 1
                  Source Chain.(Reactor -> Solver)[1].style.opacity: 1
                }
                remote SPV client: {
                  title.label: Remote SPV Client
                  (Bitcoin -> Destination Chain.SPV)[0].style.opacity: 1
                  Destination Chain.SPV.style.opacity: 1

                  Destination Chain.style.opacity: 1
                  Destination Chain.Solver.style.opacity: 1
                  Destination Chain.(Solver -> SPV)[0].style.opacity: 1
                  Destination Chain.SPV.style.opacity: 1

                  Destination Chain.Oracle.style.opacity: 1
                  Destination Chain.(SPV -> Oracle)[0].style.opacity: 1
                  (Destination Chain.Oracle -> Proof)[0].style.opacity: 1

                  Proof.style.opacity: 1
                  Source Chain.Oracle.style.opacity: 1
                  (Proof -> Source Chain.Oracle)[0].style.opacity: 1
                  Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                  Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                }
              }
            }
          }
        }
      }
    ```
  </TabItem>
  <TabItem label="Optimistic">
    ```d2 target="optimistic resolution"
      style.fill: transparent
      direction: right

      vars: {
        default-opacity: 0.1
      }

      title: System Overview {
        near: top-center
        shape: text
        style: {
          font-size: 40
        }
      }

      Order Server: {shape: cloud}

      Source Chain: {
        User: {
          shape: person
        }
        Solver: {
          style.fill-pattern: none
        }
        Reactor: {shape: page}
        Oracle: {
          style.opacity: ${default-opacity}
          shape: page
        }
        Challenger: {style.opacity: ${default-opacity}}
        SPV: {
          style.opacity: ${default-opacity}
          shape: page
        }

        Solver -> Reactor: 3. resolve() => Quote
        Solver -> Reactor: 4.1. initiate()
        User -> Reactor: 4.2. Tokens

        # Optimistic Payout
        Solver <-> Reactor: O.6.1. optimisticPayout() {style.opacity: ${default-opacity}}

        # Challenge Parts
        Challenger -> Reactor: C.6.1. dispute() {style.opacity: ${default-opacity}}

        # - Challenged Rejected (VM)
        Oracle -> Reactor: C.9.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
        Reactor -> Solver: C.9.3. payout Tokens {style.opacity: ${default-opacity}}

        # - Challenged Rejected (Bitcoin)
        Solver -> SPV: C.7.1. verify() {style.opacity: ${default-opacity}}
        SPV -> Reactor: C.7.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
        Reactor -> Solver: C.7.3. payout Tokens {style.opacity: ${default-opacity}}

        # - Challenged Accepted
        Challenger -> Reactor: C.7.1. completeDispute() {style.opacity: ${default-opacity}}
        Reactor -> Challenger: C.7.2. Reward {style.opacity: ${default-opacity}}
        Reactor -> User: C.7.3. Tokens {style.opacity: ${default-opacity}}
      }

      Source Chain.User -> Order Server: 1. Sign Message {style.animated: false}
      Order Server -> Source Chain.Solver: 2. Signed Orders

      Destination Chain: {
        Oracle: {
          shape: page
        }
        Solver
        SPV: {
          style.opacity: ${default-opacity}
          shape: page
        }
        User: {
          shape: person
        }

        # Ordinary
        Solver -> Oracle: 5.1. fill()
        Solver -> User: 5.2. Tokens

        # Challenged submit proof (VM)
        Solver -> Oracle: C.7.1. submit() {style.opacity: ${default-opacity}}

        # Challenged submit proof (Bitcoin)
        Solver -> SPV: C.7.1: verify() {style.opacity: ${default-opacity}}
        SPV -> Oracle: C.7.2. Send fill details {style.opacity: ${default-opacity}}
      }

      Bitcoin: {
        Solver: {
          style.opacity: ${default-opacity}
        }
        User: {
          shape: person
          style.opacity: ${default-opacity}
        }

        Solver -> User: 5.1 transfer {style.opacity: ${default-opacity}}
        style.opacity: ${default-opacity}
      }

      Bitcoin -> Destination Chain.SPV: Bitcoin Headers {
        style.opacity: ${default-opacity}
        style.stroke-dash: 4
      }
      Bitcoin -> Source Chain.SPV: Bitcoin Headers {
        style.opacity: ${default-opacity}
        style.stroke-dash: 4
      }

      Proof: "AMB\n" {
        shape: cloud
        style.opacity: ${default-opacity}
      }

      Destination Chain.Oracle -> Proof: C.8.1. Collect event {style.opacity: ${default-opacity}}
      Proof -> Source Chain.Oracle: C.9.1. receiveMessage() {style.opacity: ${default-opacity}}

      scenarios: {
        optimistic resolution: {
          title.label: Optimistic Resolution
          Source Chain: {
            (Solver <-> Reactor)[0].style.opacity: 1

            (Solver <-> Reactor)[0].style.stroke-width: 3
          }
        }
        challenged: {
          title.label: Challenged
          Source Chain.Challenger.style.opacity: 1
          Source Chain.(Challenger -> Reactor)[0].style.opacity: 1
          Source Chain.(Challenger -> Reactor)[0]: C.6.1. dispute()

          Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 3

          scenarios: {
            challenged uncontested: {
              title.label: Challenged Uncontested
              Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
              Source Chain.(Challenger -> Reactor)[1].style.opacity: 1
              Source Chain.(Challenger -> Reactor)[1]: C.7.1. completeDispute()

              Source Chain.(Challenger -> Reactor)[1].style.stroke-width: 3
              Source Chain.(Reactor -> Challenger)[0].style.opacity: 1
              Source Chain.(Reactor -> User)[0].style.opacity: 1
              Destination Chain.style.opacity: ${default-opacity}
              Destination Chain.*.style.opacity: ${default-opacity}
              Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
            }
            order fill proven (VM): {
              title.label: Order Fill Proven (VM)
              Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2

              Destination Chain.(Solver -> Oracle)[1].style.opacity: 1
              Destination Chain.(Solver -> Oracle)[1].style.stroke-width: 3
              Destination Chain.Oracle.style.opacity: 1
              Proof.style.opacity: 1
              (Destination Chain.Oracle -> Proof)[0].style.opacity: 1
              (Proof -> Source Chain.oracle)[0].style.opacity: 1
              Source Chain.Oracle.style.opacity: 1
              Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
              Source Chain.(Reactor -> Solver)[0].style.opacity: 1
            }
            order fill proven (BTC): {
              Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
              Destination Chain.style.opacity: ${default-opacity}
              Destination Chain.*.style.opacity: ${default-opacity}
              Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
              Bitcoin.style.opacity: 1
              Bitcoin.*.style.opacity: 1
              Bitcoin.(* -> *)[*].style.opacity: 1

              scenarios: {
                local SPV client: {
                  title.label: Local SPV Client
                  (Bitcoin -> Source Chain.SPV)[0].style.opacity: 1
                  Source Chain.SPV.style.opacity: 1

                  Source Chain.(Solver -> SPV)[0].style.opacity: 1
                  Source Chain.(Solver -> SPV)[0].style.stroke-width: 3
                  Source Chain.(SPV -> Reactor)[0].style.opacity: 1
                  Source Chain.(Reactor -> Solver)[1].style.opacity: 1
                }
                remote SPV client: {
                  title.label: Remote SPV Client
                  (Bitcoin -> Destination Chain.SPV)[0].style.opacity: 1
                  Destination Chain.SPV.style.opacity: 1

                  Destination Chain.style.opacity: 1
                  Destination Chain.Solver.style.opacity: 1
                  Destination Chain.(Solver -> SPV)[0].style.opacity: 1
                  Destination Chain.SPV.style.opacity: 1

                  Destination Chain.Oracle.style.opacity: 1
                  Destination Chain.(SPV -> Oracle)[0].style.opacity: 1
                  (Destination Chain.Oracle -> Proof)[0].style.opacity: 1

                  Proof.style.opacity: 1
                  Source Chain.Oracle.style.opacity: 1
                  (Proof -> Source Chain.Oracle)[0].style.opacity: 1
                  Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                  Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                }
              }
            }
          }
        }
      }
    ```
  </TabItem>
  <TabItem label="Challenged">
    <Tabs>
      <TabItem label="Challenged Uncontested">
        ```d2 target="challenged.challenged uncontested"
          style.fill: transparent
          direction: right

          vars: {
            default-opacity: 0.1
          }

          title: System Overview {
            near: top-center
            shape: text
            style: {
              font-size: 40
            }
          }

          Order Server: {shape: cloud}

          Source Chain: {
            User: {
              shape: person
            }
            Solver: {
              style.fill-pattern: none
            }
            Reactor: {shape: page}
            Oracle: {
              style.opacity: ${default-opacity}
              shape: page
            }
            Challenger: {style.opacity: ${default-opacity}}
            SPV: {
              style.opacity: ${default-opacity}
              shape: page
            }

            Solver -> Reactor: 3. resolve() => Quote
            Solver -> Reactor: 4.1. initiate()
            User -> Reactor: 4.2. Tokens

            # Optimistic Payout
            Solver <-> Reactor: O.6.1. optimisticPayout() {style.opacity: ${default-opacity}}

            # Challenge Parts
            Challenger -> Reactor: C.6.1. dispute() {style.opacity: ${default-opacity}}

            # - Challenged Rejected (VM)
            Oracle -> Reactor: C.9.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
            Reactor -> Solver: C.9.3. payout Tokens {style.opacity: ${default-opacity}}

            # - Challenged Rejected (Bitcoin)
            Solver -> SPV: C.7.1. verify() {style.opacity: ${default-opacity}}
            SPV -> Reactor: C.7.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
            Reactor -> Solver: C.7.3. payout Tokens {style.opacity: ${default-opacity}}

            # - Challenged Accepted
            Challenger -> Reactor: C.7.1. completeDispute() {style.opacity: ${default-opacity}}
            Reactor -> Challenger: C.7.2. Reward {style.opacity: ${default-opacity}}
            Reactor -> User: C.7.3. Tokens {style.opacity: ${default-opacity}}
          }

          Source Chain.User -> Order Server: 1. Sign Message {style.animated: false}
          Order Server -> Source Chain.Solver: 2. Signed Orders

          Destination Chain: {
            Oracle: {
              shape: page
            }
            Solver
            SPV: {
              style.opacity: ${default-opacity}
              shape: page
            }
            User: {
              shape: person
            }

            # Ordinary
            Solver -> Oracle: 5.1. fill()
            Solver -> User: 5.2. Tokens

            # Challenged submit proof (VM)
            Solver -> Oracle: C.7.1. submit() {style.opacity: ${default-opacity}}

            # Challenged submit proof (Bitcoin)
            Solver -> SPV: C.7.1: verify() {style.opacity: ${default-opacity}}
            SPV -> Oracle: C.7.2. Send fill details {style.opacity: ${default-opacity}}
          }

          Bitcoin: {
            Solver: {
              style.opacity: ${default-opacity}
            }
            User: {
              shape: person
              style.opacity: ${default-opacity}
            }

            Solver -> User: 5.1 transfer {style.opacity: ${default-opacity}}
            style.opacity: ${default-opacity}
          }

          Bitcoin -> Destination Chain.SPV: Bitcoin Headers {
            style.opacity: ${default-opacity}
            style.stroke-dash: 4
          }
          Bitcoin -> Source Chain.SPV: Bitcoin Headers {
            style.opacity: ${default-opacity}
            style.stroke-dash: 4
          }

          Proof: "AMB\n" {
            shape: cloud
            style.opacity: ${default-opacity}
          }

          Destination Chain.Oracle -> Proof: C.8.1. Collect event {style.opacity: ${default-opacity}}
          Proof -> Source Chain.Oracle: C.9.1. receiveMessage() {style.opacity: ${default-opacity}}

          scenarios: {
            optimistic resolution: {
              title.label: Optimistic Resolution
              Source Chain: {
                (Solver <-> Reactor)[0].style.opacity: 1

                (Solver <-> Reactor)[0].style.stroke-width: 3
              }
            }
            challenged: {
              title.label: Challenged
              Source Chain.Challenger.style.opacity: 1
              Source Chain.(Challenger -> Reactor)[0].style.opacity: 1
              Source Chain.(Challenger -> Reactor)[0]: C.6.1. dispute()

              Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 3

              scenarios: {
                challenged uncontested: {
                  title.label: Challenged Uncontested
                  Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
                  Source Chain.(Challenger -> Reactor)[1].style.opacity: 1
                  Source Chain.(Challenger -> Reactor)[1]: C.7.1. completeDispute()

                  Source Chain.(Challenger -> Reactor)[1].style.stroke-width: 3
                  Source Chain.(Reactor -> Challenger)[0].style.opacity: 1
                  Source Chain.(Reactor -> User)[0].style.opacity: 1
                  Destination Chain.style.opacity: ${default-opacity}
                  Destination Chain.*.style.opacity: ${default-opacity}
                  Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
                }
                order fill proven (VM): {
                  title.label: Order Fill Proven (VM)
                  Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2

                  Destination Chain.(Solver -> Oracle)[1].style.opacity: 1
                  Destination Chain.(Solver -> Oracle)[1].style.stroke-width: 3
                  Destination Chain.Oracle.style.opacity: 1
                  Proof.style.opacity: 1
                  (Destination Chain.Oracle -> Proof)[0].style.opacity: 1
                  (Proof -> Source Chain.oracle)[0].style.opacity: 1
                  Source Chain.Oracle.style.opacity: 1
                  Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                  Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                }
                order fill proven (BTC): {
                  Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
                  Destination Chain.style.opacity: ${default-opacity}
                  Destination Chain.*.style.opacity: ${default-opacity}
                  Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
                  Bitcoin.style.opacity: 1
                  Bitcoin.*.style.opacity: 1
                  Bitcoin.(* -> *)[*].style.opacity: 1

                  scenarios: {
                    local SPV client: {
                      title.label: Local SPV Client
                      (Bitcoin -> Source Chain.SPV)[0].style.opacity: 1
                      Source Chain.SPV.style.opacity: 1

                      Source Chain.(Solver -> SPV)[0].style.opacity: 1
                      Source Chain.(Solver -> SPV)[0].style.stroke-width: 3
                      Source Chain.(SPV -> Reactor)[0].style.opacity: 1
                      Source Chain.(Reactor -> Solver)[1].style.opacity: 1
                    }
                    remote SPV client: {
                      title.label: Remote SPV Client
                      (Bitcoin -> Destination Chain.SPV)[0].style.opacity: 1
                      Destination Chain.SPV.style.opacity: 1

                      Destination Chain.style.opacity: 1
                      Destination Chain.Solver.style.opacity: 1
                      Destination Chain.(Solver -> SPV)[0].style.opacity: 1
                      Destination Chain.SPV.style.opacity: 1

                      Destination Chain.Oracle.style.opacity: 1
                      Destination Chain.(SPV -> Oracle)[0].style.opacity: 1
                      (Destination Chain.Oracle -> Proof)[0].style.opacity: 1

                      Proof.style.opacity: 1
                      Source Chain.Oracle.style.opacity: 1
                      (Proof -> Source Chain.Oracle)[0].style.opacity: 1
                      Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                      Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                    }
                  }
                }
              }
            }
          }
        ```
      </TabItem>
      <TabItem label="VM Proof">
        ```d2 target="challenged.order fill proven (VM)"
          style.fill: transparent
          direction: right

          vars: {
            default-opacity: 0.1
          }

          title: System Overview {
            near: top-center
            shape: text
            style: {
              font-size: 40
            }
          }

          Order Server: {shape: cloud}

          Source Chain: {
            User: {
              shape: person
            }
            Solver: {
              style.fill-pattern: none
            }
            Reactor: {shape: page}
            Oracle: {
              style.opacity: ${default-opacity}
              shape: page
            }
            Challenger: {style.opacity: ${default-opacity}}
            SPV: {
              style.opacity: ${default-opacity}
              shape: page
            }

            Solver -> Reactor: 3. resolve() => Quote
            Solver -> Reactor: 4.1. initiate()
            User -> Reactor: 4.2. Tokens

            # Optimistic Payout
            Solver <-> Reactor: O.6.1. optimisticPayout() {style.opacity: ${default-opacity}}

            # Challenge Parts
            Challenger -> Reactor: C.6.1. dispute() {style.opacity: ${default-opacity}}

            # - Challenged Rejected (VM)
            Oracle -> Reactor: C.9.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
            Reactor -> Solver: C.9.3. payout Tokens {style.opacity: ${default-opacity}}

            # - Challenged Rejected (Bitcoin)
            Solver -> SPV: C.7.1. verify() {style.opacity: ${default-opacity}}
            SPV -> Reactor: C.7.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
            Reactor -> Solver: C.7.3. payout Tokens {style.opacity: ${default-opacity}}

            # - Challenged Accepted
            Challenger -> Reactor: C.7.1. completeDispute() {style.opacity: ${default-opacity}}
            Reactor -> Challenger: C.7.2. Reward {style.opacity: ${default-opacity}}
            Reactor -> User: C.7.3. Tokens {style.opacity: ${default-opacity}}
          }

          Source Chain.User -> Order Server: 1. Sign Message {style.animated: false}
          Order Server -> Source Chain.Solver: 2. Signed Orders

          Destination Chain: {
            Oracle: {
              shape: page
            }
            Solver
            SPV: {
              style.opacity: ${default-opacity}
              shape: page
            }
            User: {
              shape: person
            }

            # Ordinary
            Solver -> Oracle: 5.1. fill()
            Solver -> User: 5.2. Tokens

            # Challenged submit proof (VM)
            Solver -> Oracle: C.7.1. submit() {style.opacity: ${default-opacity}}

            # Challenged submit proof (Bitcoin)
            Solver -> SPV: C.7.1: verify() {style.opacity: ${default-opacity}}
            SPV -> Oracle: C.7.2. Send fill details {style.opacity: ${default-opacity}}
          }

          Bitcoin: {
            Solver: {
              style.opacity: ${default-opacity}
            }
            User: {
              shape: person
              style.opacity: ${default-opacity}
            }

            Solver -> User: 5.1 transfer {style.opacity: ${default-opacity}}
            style.opacity: ${default-opacity}
          }

          Bitcoin -> Destination Chain.SPV: Bitcoin Headers {
            style.opacity: ${default-opacity}
            style.stroke-dash: 4
          }
          Bitcoin -> Source Chain.SPV: Bitcoin Headers {
            style.opacity: ${default-opacity}
            style.stroke-dash: 4
          }

          Proof: "AMB\n" {
            shape: cloud
            style.opacity: ${default-opacity}
          }

          Destination Chain.Oracle -> Proof: C.8.1. Collect event {style.opacity: ${default-opacity}}
          Proof -> Source Chain.Oracle: C.9.1. receiveMessage() {style.opacity: ${default-opacity}}

          scenarios: {
            optimistic resolution: {
              title.label: Optimistic Resolution
              Source Chain: {
                (Solver <-> Reactor)[0].style.opacity: 1

                (Solver <-> Reactor)[0].style.stroke-width: 3
              }
            }
            challenged: {
              title.label: Challenged
              Source Chain.Challenger.style.opacity: 1
              Source Chain.(Challenger -> Reactor)[0].style.opacity: 1
              Source Chain.(Challenger -> Reactor)[0]: C.6.1. dispute()

              Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 3

              scenarios: {
                challenged uncontested: {
                  title.label: Challenged Uncontested
                  Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
                  Source Chain.(Challenger -> Reactor)[1].style.opacity: 1
                  Source Chain.(Challenger -> Reactor)[1]: C.7.1. completeDispute()

                  Source Chain.(Challenger -> Reactor)[1].style.stroke-width: 3
                  Source Chain.(Reactor -> Challenger)[0].style.opacity: 1
                  Source Chain.(Reactor -> User)[0].style.opacity: 1
                  Destination Chain.style.opacity: ${default-opacity}
                  Destination Chain.*.style.opacity: ${default-opacity}
                  Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
                }
                order fill proven (VM): {
                  title.label: Order Fill Proven (VM)
                  Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2

                  Destination Chain.(Solver -> Oracle)[1].style.opacity: 1
                  Destination Chain.(Solver -> Oracle)[1].style.stroke-width: 3
                  Destination Chain.Oracle.style.opacity: 1
                  Proof.style.opacity: 1
                  (Destination Chain.Oracle -> Proof)[0].style.opacity: 1
                  (Proof -> Source Chain.oracle)[0].style.opacity: 1
                  Source Chain.Oracle.style.opacity: 1
                  Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                  Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                }
                order fill proven (BTC): {
                  Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
                  Destination Chain.style.opacity: ${default-opacity}
                  Destination Chain.*.style.opacity: ${default-opacity}
                  Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
                  Bitcoin.style.opacity: 1
                  Bitcoin.*.style.opacity: 1
                  Bitcoin.(* -> *)[*].style.opacity: 1

                  scenarios: {
                    local SPV client: {
                      title.label: Local SPV Client
                      (Bitcoin -> Source Chain.SPV)[0].style.opacity: 1
                      Source Chain.SPV.style.opacity: 1

                      Source Chain.(Solver -> SPV)[0].style.opacity: 1
                      Source Chain.(Solver -> SPV)[0].style.stroke-width: 3
                      Source Chain.(SPV -> Reactor)[0].style.opacity: 1
                      Source Chain.(Reactor -> Solver)[1].style.opacity: 1
                    }
                    remote SPV client: {
                      title.label: Remote SPV Client
                      (Bitcoin -> Destination Chain.SPV)[0].style.opacity: 1
                      Destination Chain.SPV.style.opacity: 1

                      Destination Chain.style.opacity: 1
                      Destination Chain.Solver.style.opacity: 1
                      Destination Chain.(Solver -> SPV)[0].style.opacity: 1
                      Destination Chain.SPV.style.opacity: 1

                      Destination Chain.Oracle.style.opacity: 1
                      Destination Chain.(SPV -> Oracle)[0].style.opacity: 1
                      (Destination Chain.Oracle -> Proof)[0].style.opacity: 1

                      Proof.style.opacity: 1
                      Source Chain.Oracle.style.opacity: 1
                      (Proof -> Source Chain.Oracle)[0].style.opacity: 1
                      Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                      Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                    }
                  }
                }
              }
            }
          }
        ```
      </TabItem>
      <TabItem label="BTC Proof">
        <Tabs>
          <TabItem label="Local SPV Client">
            ```d2 target="challenged.order fill proven (BTC).local SPV client"
              style.fill: transparent
              direction: right

              vars: {
                default-opacity: 0.1
              }

              title: System Overview {
                near: top-center
                shape: text
                style: {
                  font-size: 40
                }
              }

              Order Server: {shape: cloud}

              Source Chain: {
                User: {
                  shape: person
                }
                Solver: {
                  style.fill-pattern: none
                }
                Reactor: {shape: page}
                Oracle: {
                  style.opacity: ${default-opacity}
                  shape: page
                }
                Challenger: {style.opacity: ${default-opacity}}
                SPV: {
                  style.opacity: ${default-opacity}
                  shape: page
                }

                Solver -> Reactor: 3. resolve() => Quote
                Solver -> Reactor: 4.1. initiate()
                User -> Reactor: 4.2. Tokens

                # Optimistic Payout
                Solver <-> Reactor: O.6.1. optimisticPayout() {style.opacity: ${default-opacity}}

                # Challenge Parts
                Challenger -> Reactor: C.6.1. dispute() {style.opacity: ${default-opacity}}

                # - Challenged Rejected (VM)
                Oracle -> Reactor: C.9.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
                Reactor -> Solver: C.9.3. payout Tokens {style.opacity: ${default-opacity}}

                # - Challenged Rejected (Bitcoin)
                Solver -> SPV: C.7.1. verify() {style.opacity: ${default-opacity}}
                SPV -> Reactor: C.7.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
                Reactor -> Solver: C.7.3. payout Tokens {style.opacity: ${default-opacity}}

                # - Challenged Accepted
                Challenger -> Reactor: C.7.1. completeDispute() {style.opacity: ${default-opacity}}
                Reactor -> Challenger: C.7.2. Reward {style.opacity: ${default-opacity}}
                Reactor -> User: C.7.3. Tokens {style.opacity: ${default-opacity}}
              }

              Source Chain.User -> Order Server: 1. Sign Message {style.animated: false}
              Order Server -> Source Chain.Solver: 2. Signed Orders

              Destination Chain: {
                Oracle: {
                  shape: page
                }
                Solver
                SPV: {
                  style.opacity: ${default-opacity}
                  shape: page
                }
                User: {
                  shape: person
                }

                # Ordinary
                Solver -> Oracle: 5.1. fill()
                Solver -> User: 5.2. Tokens

                # Challenged submit proof (VM)
                Solver -> Oracle: C.7.1. submit() {style.opacity: ${default-opacity}}

                # Challenged submit proof (Bitcoin)
                Solver -> SPV: C.7.1: verify() {style.opacity: ${default-opacity}}
                SPV -> Oracle: C.7.2. Send fill details {style.opacity: ${default-opacity}}
              }

              Bitcoin: {
                Solver: {
                  style.opacity: ${default-opacity}
                }
                User: {
                  shape: person
                  style.opacity: ${default-opacity}
                }

                Solver -> User: 5.1 transfer {style.opacity: ${default-opacity}}
                style.opacity: ${default-opacity}
              }

              Bitcoin -> Destination Chain.SPV: Bitcoin Headers {
                style.opacity: ${default-opacity}
                style.stroke-dash: 4
              }
              Bitcoin -> Source Chain.SPV: Bitcoin Headers {
                style.opacity: ${default-opacity}
                style.stroke-dash: 4
              }

              Proof: "AMB\n" {
                shape: cloud
                style.opacity: ${default-opacity}
              }

              Destination Chain.Oracle -> Proof: C.8.1. Collect event {style.opacity: ${default-opacity}}
              Proof -> Source Chain.Oracle: C.9.1. receiveMessage() {style.opacity: ${default-opacity}}

              scenarios: {
                optimistic resolution: {
                  title.label: Optimistic Resolution
                  Source Chain: {
                    (Solver <-> Reactor)[0].style.opacity: 1

                    (Solver <-> Reactor)[0].style.stroke-width: 3
                  }
                }
                challenged: {
                  title.label: Challenged
                  Source Chain.Challenger.style.opacity: 1
                  Source Chain.(Challenger -> Reactor)[0].style.opacity: 1
                  Source Chain.(Challenger -> Reactor)[0]: C.6.1. dispute()

                  Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 3

                  scenarios: {
                    challenged uncontested: {
                      title.label: Challenged Uncontested
                      Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
                      Source Chain.(Challenger -> Reactor)[1].style.opacity: 1
                      Source Chain.(Challenger -> Reactor)[1]: C.7.1. completeDispute()

                      Source Chain.(Challenger -> Reactor)[1].style.stroke-width: 3
                      Source Chain.(Reactor -> Challenger)[0].style.opacity: 1
                      Source Chain.(Reactor -> User)[0].style.opacity: 1
                      Destination Chain.style.opacity: ${default-opacity}
                      Destination Chain.*.style.opacity: ${default-opacity}
                      Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
                    }
                    order fill proven (VM): {
                      title.label: Order Fill Proven (VM)
                      Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2

                      Destination Chain.(Solver -> Oracle)[1].style.opacity: 1
                      Destination Chain.(Solver -> Oracle)[1].style.stroke-width: 3
                      Destination Chain.Oracle.style.opacity: 1
                      Proof.style.opacity: 1
                      (Destination Chain.Oracle -> Proof)[0].style.opacity: 1
                      (Proof -> Source Chain.oracle)[0].style.opacity: 1
                      Source Chain.Oracle.style.opacity: 1
                      Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                      Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                    }
                    order fill proven (BTC): {
                      Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
                      Destination Chain.style.opacity: ${default-opacity}
                      Destination Chain.*.style.opacity: ${default-opacity}
                      Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
                      Bitcoin.style.opacity: 1
                      Bitcoin.*.style.opacity: 1
                      Bitcoin.(* -> *)[*].style.opacity: 1

                      scenarios: {
                        local SPV client: {
                          title.label: Local SPV Client
                          (Bitcoin -> Source Chain.SPV)[0].style.opacity: 1
                          Source Chain.SPV.style.opacity: 1

                          Source Chain.(Solver -> SPV)[0].style.opacity: 1
                          Source Chain.(Solver -> SPV)[0].style.stroke-width: 3
                          Source Chain.(SPV -> Reactor)[0].style.opacity: 1
                          Source Chain.(Reactor -> Solver)[1].style.opacity: 1
                        }
                        remote SPV client: {
                          title.label: Remote SPV Client
                          (Bitcoin -> Destination Chain.SPV)[0].style.opacity: 1
                          Destination Chain.SPV.style.opacity: 1

                          Destination Chain.style.opacity: 1
                          Destination Chain.Solver.style.opacity: 1
                          Destination Chain.(Solver -> SPV)[0].style.opacity: 1
                          Destination Chain.SPV.style.opacity: 1

                          Destination Chain.Oracle.style.opacity: 1
                          Destination Chain.(SPV -> Oracle)[0].style.opacity: 1
                          (Destination Chain.Oracle -> Proof)[0].style.opacity: 1

                          Proof.style.opacity: 1
                          Source Chain.Oracle.style.opacity: 1
                          (Proof -> Source Chain.Oracle)[0].style.opacity: 1
                          Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                          Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                        }
                      }
                    }
                  }
                }
              }
            ```
          </TabItem>
          <TabItem label="Remote SPV client">
            ```d2 target="challenged.order fill proven (BTC).remote SPV client"
              style.fill: transparent
              direction: right

              vars: {
                default-opacity: 0.1
              }

              title: System Overview {
                near: top-center
                shape: text
                style: {
                  font-size: 40
                }
              }

              Order Server: {shape: cloud}

              Source Chain: {
                User: {
                  shape: person
                }
                Solver: {
                  style.fill-pattern: none
                }
                Reactor: {shape: page}
                Oracle: {
                  style.opacity: ${default-opacity}
                  shape: page
                }
                Challenger: {style.opacity: ${default-opacity}}
                SPV: {
                  style.opacity: ${default-opacity}
                  shape: page
                }

                Solver -> Reactor: 3. resolve() => Quote
                Solver -> Reactor: 4.1. initiate()
                User -> Reactor: 4.2. Tokens

                # Optimistic Payout
                Solver <-> Reactor: O.6.1. optimisticPayout() {style.opacity: ${default-opacity}}

                # Challenge Parts
                Challenger -> Reactor: C.6.1. dispute() {style.opacity: ${default-opacity}}

                # - Challenged Rejected (VM)
                Oracle -> Reactor: C.9.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
                Reactor -> Solver: C.9.3. payout Tokens {style.opacity: ${default-opacity}}

                # - Challenged Rejected (Bitcoin)
                Solver -> SPV: C.7.1. verify() {style.opacity: ${default-opacity}}
                SPV -> Reactor: C.7.2. proveOrderFulfilment() {style.opacity: ${default-opacity}}
                Reactor -> Solver: C.7.3. payout Tokens {style.opacity: ${default-opacity}}

                # - Challenged Accepted
                Challenger -> Reactor: C.7.1. completeDispute() {style.opacity: ${default-opacity}}
                Reactor -> Challenger: C.7.2. Reward {style.opacity: ${default-opacity}}
                Reactor -> User: C.7.3. Tokens {style.opacity: ${default-opacity}}
              }

              Source Chain.User -> Order Server: 1. Sign Message {style.animated: false}
              Order Server -> Source Chain.Solver: 2. Signed Orders

              Destination Chain: {
                Oracle: {
                  shape: page
                }
                Solver
                SPV: {
                  style.opacity: ${default-opacity}
                  shape: page
                }
                User: {
                  shape: person
                }

                # Ordinary
                Solver -> Oracle: 5.1. fill()
                Solver -> User: 5.2. Tokens

                # Challenged submit proof (VM)
                Solver -> Oracle: C.7.1. submit() {style.opacity: ${default-opacity}}

                # Challenged submit proof (Bitcoin)
                Solver -> SPV: C.7.1: verify() {style.opacity: ${default-opacity}}
                SPV -> Oracle: C.7.2. Send fill details {style.opacity: ${default-opacity}}
              }

              Bitcoin: {
                Solver: {
                  style.opacity: ${default-opacity}
                }
                User: {
                  shape: person
                  style.opacity: ${default-opacity}
                }

                Solver -> User: 5.1 transfer {style.opacity: ${default-opacity}}
                style.opacity: ${default-opacity}
              }

              Bitcoin -> Destination Chain.SPV: Bitcoin Headers {
                style.opacity: ${default-opacity}
                style.stroke-dash: 4
              }
              Bitcoin -> Source Chain.SPV: Bitcoin Headers {
                style.opacity: ${default-opacity}
                style.stroke-dash: 4
              }

              Proof: "AMB\n" {
                shape: cloud
                style.opacity: ${default-opacity}
              }

              Destination Chain.Oracle -> Proof: C.8.1. Collect event {style.opacity: ${default-opacity}}
              Proof -> Source Chain.Oracle: C.9.1. receiveMessage() {style.opacity: ${default-opacity}}

              scenarios: {
                optimistic resolution: {
                  title.label: Optimistic Resolution
                  Source Chain: {
                    (Solver <-> Reactor)[0].style.opacity: 1

                    (Solver <-> Reactor)[0].style.stroke-width: 3
                  }
                }
                challenged: {
                  title.label: Challenged
                  Source Chain.Challenger.style.opacity: 1
                  Source Chain.(Challenger -> Reactor)[0].style.opacity: 1
                  Source Chain.(Challenger -> Reactor)[0]: C.6.1. dispute()

                  Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 3

                  scenarios: {
                    challenged uncontested: {
                      title.label: Challenged Uncontested
                      Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
                      Source Chain.(Challenger -> Reactor)[1].style.opacity: 1
                      Source Chain.(Challenger -> Reactor)[1]: C.7.1. completeDispute()

                      Source Chain.(Challenger -> Reactor)[1].style.stroke-width: 3
                      Source Chain.(Reactor -> Challenger)[0].style.opacity: 1
                      Source Chain.(Reactor -> User)[0].style.opacity: 1
                      Destination Chain.style.opacity: ${default-opacity}
                      Destination Chain.*.style.opacity: ${default-opacity}
                      Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
                    }
                    order fill proven (VM): {
                      title.label: Order Fill Proven (VM)
                      Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2

                      Destination Chain.(Solver -> Oracle)[1].style.opacity: 1
                      Destination Chain.(Solver -> Oracle)[1].style.stroke-width: 3
                      Destination Chain.Oracle.style.opacity: 1
                      Proof.style.opacity: 1
                      (Destination Chain.Oracle -> Proof)[0].style.opacity: 1
                      (Proof -> Source Chain.oracle)[0].style.opacity: 1
                      Source Chain.Oracle.style.opacity: 1
                      Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                      Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                    }
                    order fill proven (BTC): {
                      Source Chain.(Challenger -> Reactor)[0].style.stroke-width: 2
                      Destination Chain.style.opacity: ${default-opacity}
                      Destination Chain.*.style.opacity: ${default-opacity}
                      Destination Chain.(* -> *)[*].style.opacity: ${default-opacity}
                      Bitcoin.style.opacity: 1
                      Bitcoin.*.style.opacity: 1
                      Bitcoin.(* -> *)[*].style.opacity: 1

                      scenarios: {
                        local SPV client: {
                          title.label: Local SPV Client
                          (Bitcoin -> Source Chain.SPV)[0].style.opacity: 1
                          Source Chain.SPV.style.opacity: 1

                          Source Chain.(Solver -> SPV)[0].style.opacity: 1
                          Source Chain.(Solver -> SPV)[0].style.stroke-width: 3
                          Source Chain.(SPV -> Reactor)[0].style.opacity: 1
                          Source Chain.(Reactor -> Solver)[1].style.opacity: 1
                        }
                        remote SPV client: {
                          title.label: Remote SPV Client
                          (Bitcoin -> Destination Chain.SPV)[0].style.opacity: 1
                          Destination Chain.SPV.style.opacity: 1

                          Destination Chain.style.opacity: 1
                          Destination Chain.Solver.style.opacity: 1
                          Destination Chain.(Solver -> SPV)[0].style.opacity: 1
                          Destination Chain.SPV.style.opacity: 1

                          Destination Chain.Oracle.style.opacity: 1
                          Destination Chain.(SPV -> Oracle)[0].style.opacity: 1
                          (Destination Chain.Oracle -> Proof)[0].style.opacity: 1

                          Proof.style.opacity: 1
                          Source Chain.Oracle.style.opacity: 1
                          (Proof -> Source Chain.Oracle)[0].style.opacity: 1
                          Source Chain.(Oracle -> Reactor)[0].style.opacity: 1
                          Source Chain.(Reactor -> Solver)[0].style.opacity: 1
                        }
                      }
                    }
                  }
                }
              }
            ```
          </TabItem>
        </Tabs>
      </TabItem>
    </Tabs>
  </TabItem>
</Tabs>

## System Overview

Cross-Cats is designed for cross-chain intents. Nevertheless, the majority of logic exists on the source chain. **Source Chain** here refers to the chain where the order was **Initiated** by a solver. **Remote Chain** refers to the chain (or chains) where proofs are sent from. This includes asset deliveries.

### Initiation (order claim)

An order is initiated by the user signing an order description. An example of an order description is _My 1 Ether (Ethereum) for 3000 USD (Base)_. The signed order is a permit2 witness allowing the solver to submit the order to the Reactor and collect the **input** (1 Ether) from the user. Importantly, during this step, some collateral is collected from the solver. This ensures the solver has some skin in the game and settles the order. The collateral is paid back when the input is released to the solver.

To improve the user and solver experience, an order server sits between the user and solver and aids with order validation, propagation, and quoting.

### Output Payment (to user)

The payment pathway depends on the order intent. For a **VM to VM** swap, the solver calls the oracle contract on the destination chain, which sends & records the token payment to the user. For **VM to Bitcoin** swap, the solver makes the payment described in the order. In other words, make a Bitcoin transaction that has **a** UTXO that matches the order description. Using an SPV client, the transaction containing the UTXO can be proven to exist.

### Input Payment (to solver)

Cross Cats has 3 payment release schemes to optimise the solver experience.

1. Optimistic resolution. This assumes that the resolver delivered the payment to the user. After a dispute window (configured by the user), the payment will be released. If the order is disputed, the operation falls back to option 2.
2. Explicit validation. At any time, orders can be proven. This requires that someone send the proof from the remote chains to the source chain. This is more costly than optimistic resolution, but may be significantly faster than optimistic resolution. Additionally, through batch verification, the cost can be reduced at a slight increase in verification speed.
3. Underwriting. The last release scheme isn't a payment proof scheme as much as it is a responsibility delegation scheme. If configured, an order can be bought by someone else at any point prior to the release of the input. This allows the initial solver to immediately get their capital back and hand off the payment validation to a third party.

By using these 3 schemes in conjunction with each other, solvers only have to lock liquidity for a small period of time while not sacrificing any system security. At the same time, speed, security, and cost can be rebalanced based on the specific needs of a user or chain conditions.

## Bitcoin & Pseudo Solving

VM to Bitcoin swaps are relatively straight forward:
1. User signs a message stating the input assets.
2. Solver claims the order, inputs assets are automatically collected.
3. Solver delivers assets.
4. Solver is paid.

However, this flow breaks on step 2 when the user wants to go from Bitcoin to VM. (sell Bitcoin). There is no way to pull assets from a user. To solve this issue, the user becomes a **pseudo solver** & relies on release scheme 3. Pseudo solving works by asking solvers for short-lived Bitcoin short quotes. These orders are after validation & selection signed by the solver. The user then quickly claims the order.

Say the user wants to swap 1 Bitcoin for 50000 USDC. Using the order server, they need to collect & claim a signed order of the opposite: 50000 USDC for 1 Bitcoin. Once this order is filled, they get the input (50000 USDC) which matches their desired swap.

Important to notice, this adds a delay between when the price risk begins for the solver (issuance of signed order) to when it resolves (0-1 block confirmations of Bitcoin TXO). These values are best migrated by the following configuration:
1. Short initiation time. Using a source chain with a low block time, the initiation time can be kept to an absolute minimum.
2. Short proof time. The user may only have 1 or 2 Blocks to get their transaction confirmed.
3. Designing a compatibility layer between the UI and the Order Server that only requests binding order when it is known that the user can get their Bitcoins filled.

In a future version, VM to Bitcoin swaps will upgrade to an oracle book scheme that further minimizes time between start of price risk to end of price risk.

## Key differentiators

Cross-Cats has been designed to optimise solver integration metrics:
- Cost of capital – Capital is only held for the duration of a swap and can be underwritten to further decrease the lock duration.
- Speed – Minimizing settlement overhead, users receive their assets immediately, while solvers can opt in to underwriting for quick input payout.
- Price Risk – Price Risk is minimized by letting solvers commit to swaps & providing strong order guarantees.

### Locked Capital & Underwriting

Cross-Cats has no concept of pre-locking liquidity. Capital is only locked during the actual order flow. Additionally, Users will immediately receive their assets as deliveries are directly from the solver to the user.

Additionally, for routes supported by underwriters input assets will be available 1-5 minutes after asset delivery. This includes Bitcoin routes for users.

### Price (un)Certainty

For VM to VM swaps and VM to Bitcoin swaps, the price uncertainty window is the time it takes from the moment your system commits to the order – which may be the initiate transaction – to when the order claim arrives on-chain and is successfully mined. On fast chains this is at most 2-3 seconds but may be up-to 12 seconds. Cleverly timing the commitment can reduce the uncertainty period below the block time.

For Bitcoin to VM swaps the price uncertainty window is from when the order is signed to when the user initiates the Bitcoin transaction and it gets your desired number of confirmations. This may vary from 30 seconds to 60 seconds.

Cross-Cats has developed a user owned pseudo escrow, that allows the Order Server to give a soft commitment to solvers that a Bitcoin UTXO will be generated. Given that a solver trusts this promise, the price uncertainty window is as low as 30 seconds or shorter.
